;; The first three lines of this file were inserted by DrRacket. They record metadata
;; about the language level of this file in a form that our tools can easily process.
#reader(lib "htdp-beginner-reader.ss" "lang")((modname exersice_2) (read-case-sensitive #t) (teachpacks ()) (htdp-settings #(#t constructor repeating-decimal #f #t none #f () #f)))
;exersice_2.37

(define (matrix-*-vector m v)
(map <??> m))
(define (transpose mat)
(accumulate-n <??> <??> mat))
(define (matrix-*-matrix m n)
(let ((cols (transpose n)))
(map <??> m)))

;Solution
(define (dot-product v w)
  (accumulate + 0 (map * v w)))

(define (matrix-*-vector m v)
  (map (lambda (row) (dot-product row v)) m))
(define (transpose mat)
  (accumulate-n cons '() mat))

; The way to multiply two matricies proceeds as follows: In the
; process of mapping every row, we need to map every element in the
; row to the dot product of the current row and the corresponding
; column of the element. The only tricky part is getting the
; corresponding column of the row element. We achieve this by using
; the special form of map that takes in a procedure of n arguments
; with n lists and applies the procedure to the first element in each
; list and returns a new list of the result after doing this to every
; element.
;
; Note that when we define the second map on each element, the row is
; still in scope, which is critical to being able to retrieve the
; corresponding row & column of an element.
(define (matrix-*-matrix m n)
  (let ((cols (transpose n)))
    (map (lambda (row)
           (map (lambda (elem col) (dot-product row col))
                row cols)) m)))