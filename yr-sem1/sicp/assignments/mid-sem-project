#lang racket
;(define (make-point x y)
;(cons x y))
;(define (point-x p)
;(car p))
;(define (point-y p)
;(cdr p))
;(define (pretty-print p)
;(list 'x: (point-x p) 'y: (point-y p)))

;solution
(define (make-point x y)
(cons x y))
(define (point-x make-point p)
  (car p)
 (set-x! p x))

(define (point-y make-point p)
  (cdr p)
  (set-y! p y))

;cloning the original copy
(define (clone make-point)
  (define (returning-copy make-point)
    (lambda() clone)
    (point-x p)
    (point-y (returning-copy point-x)
             (define copied-object (point-y))))
  (define x (list 1 2 3 4))
  (define y (returning-copy x))
  (define copy-x (y))
  (set-dr! x 'foo)
  )

(define (helper-func pp1 p2)
  (if(null? p1)
     0
     (+(* (-(car p1) ( car p2)
            (+(* (-(car p1) ( car p2))
                 (helper-func (cdr p1) (cdr p2))))))))
(define (distance p1 p2)
  (sqrt (helper-func p1 p2 ))))



(define (distance p1 p2)
  (let ((dx (- (point-x p1) (point-y p2))))
    (sqrt (+(* dx dx) (* dy dy)))))
